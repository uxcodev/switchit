'use strict';

var vue = require('vue');
var auth0SpaJs = require('@auth0/auth0-spa-js');

/**
 * @ignore
 */
const AUTH0_TOKEN = '$auth0';
/**
 * Injection token used to `provide` the `Auth0VueClient` instance. Can be used to pass to `inject()`
 *
 * ```js
 * inject(AUTH0_INJECTION_KEY)
 * ```
 */
const AUTH0_INJECTION_KEY = Symbol(AUTH0_TOKEN);

var version = '2.0.0';

/**
 * @ignore
 * Helper function to bind methods to itself, useful when using Vue's `provide` / `inject` API's.
 */
function bindPluginMethods(plugin, exclude) {
    Object.getOwnPropertyNames(Object.getPrototypeOf(plugin))
        .filter(method => !exclude.includes(method))
        // eslint-disable-next-line security/detect-object-injection
        .forEach(method => (plugin[method] = plugin[method].bind(plugin)));
}

/**
 * @ignore
 */
const client = vue.ref(null);
/**
 * @ignore
 */
class Auth0Plugin {
    constructor(clientOptions, pluginOptions) {
        this.clientOptions = clientOptions;
        this.pluginOptions = pluginOptions;
        this._isLoading = vue.ref(true);
        this._isAuthenticated = vue.ref(false);
        this._user = vue.ref({});
        this._idTokenClaims = vue.ref();
        this._error = vue.ref(null);
        this.isLoading = vue.readonly(this._isLoading);
        this.isAuthenticated = vue.readonly(this._isAuthenticated);
        this.user = vue.readonly(this._user);
        this.idTokenClaims = vue.readonly(this._idTokenClaims);
        this.error = vue.readonly(this._error);
        // Vue Plugins can have issues when passing around the instance to `provide`
        // Therefor we need to bind all methods correctly to `this`.
        bindPluginMethods(this, ['constructor']);
    }
    install(app) {
        this._client = new auth0SpaJs.Auth0Client(Object.assign(Object.assign({}, this.clientOptions), { auth0Client: {
                name: 'auth0-vue',
                version: version
            } }));
        this.__checkSession(app.config.globalProperties.$router);
        // eslint-disable-next-line security/detect-object-injection
        app.config.globalProperties[AUTH0_TOKEN] = this;
        app.provide(AUTH0_INJECTION_KEY, this);
        client.value = this;
    }
    async loginWithRedirect(options) {
        return this._client.loginWithRedirect(options);
    }
    async loginWithPopup(options, config) {
        return this.__proxy(() => this._client.loginWithPopup(options, config));
    }
    async logout(options) {
        if ((options === null || options === void 0 ? void 0 : options.openUrl) || (options === null || options === void 0 ? void 0 : options.openUrl) === false) {
            return this.__proxy(() => this._client.logout(options));
        }
        return this._client.logout(options);
    }
    /* istanbul ignore next */
    async getAccessTokenSilently(options = {}) {
        return this.__proxy(() => this._client.getTokenSilently(options));
    }
    async getAccessTokenWithPopup(options, config) {
        return this.__proxy(() => this._client.getTokenWithPopup(options, config));
    }
    async checkSession(options) {
        return this.__proxy(() => this._client.checkSession(options));
    }
    async handleRedirectCallback(url) {
        return this.__proxy(() => this._client.handleRedirectCallback(url));
    }
    async __checkSession(router) {
        var _a, _b;
        const search = window.location.search;
        if ((search.includes('code=') || search.includes('error=')) &&
            search.includes('state=') &&
            !((_a = this.pluginOptions) === null || _a === void 0 ? void 0 : _a.skipRedirectCallback)) {
            const result = await this.handleRedirectCallback();
            const appState = result === null || result === void 0 ? void 0 : result.appState;
            const target = (_b = appState === null || appState === void 0 ? void 0 : appState.target) !== null && _b !== void 0 ? _b : '/';
            window.history.replaceState({}, '', '/');
            if (router) {
                router.push(target);
            }
            return result;
        }
        else {
            await this.checkSession();
        }
    }
    async __refreshState() {
        this._isAuthenticated.value = await this._client.isAuthenticated();
        this._user.value = await this._client.getUser();
        this._idTokenClaims.value = await this._client.getIdTokenClaims();
        this._isLoading.value = false;
    }
    async __proxy(cb, refreshState = true) {
        let result;
        try {
            result = await cb();
            this._error.value = null;
        }
        catch (e) {
            this._error.value = e;
            throw e;
        }
        finally {
            if (refreshState) {
                await this.__refreshState();
            }
        }
        return result;
    }
}

/**
 * Creates the Auth0 plugin.
 *
 * @param clientOptions The Auth Vue Client Options
 * @param pluginOptions Additional Plugin Configuration Options
 * @returns An instance of Auth0Plugin
 */
function createAuth0(clientOptions, pluginOptions) {
    return new Auth0Plugin(clientOptions, pluginOptions);
}
/**
 * Returns the registered Auth0 instance using Vue's `inject`.
 * @returns An instance of Auth0VueClient
 */
function useAuth0() {
    return vue.inject(AUTH0_INJECTION_KEY);
}

const Auth0Vue = { createAuth0, useAuth0 };

module.exports = Auth0Vue;
//# sourceMappingURL=auth0-vue.cjs.js.map
